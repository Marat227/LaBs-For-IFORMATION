#include <iostream>
#include <cmath>
#include <ctime>
using namespace std;

//Блочная сортировка
const int ARRAY_SIZE = 10;
const int BUCKET_SIZE = 10;
void bucketSort(int arr[], int size) {
    int max_val = arr[0];
    int min_val = arr[0];


    for (int i = 1; i < size; i++) {// Найти максимальный и минимальный элементы в массиве
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        if (arr[i] < min_val) {
            min_val = arr[i];
        }
    }


    float range = (float)(max_val - min_val + 1) / BUCKET_SIZE; // Вычислить размер каждого блока


    int buckets[BUCKET_SIZE][ARRAY_SIZE] = { 0 }; // Создать массив блоков и массив размеров блоков
    int bucket_sizes[BUCKET_SIZE] = { 0 };


    for (int i = 0; i < size; i++) { // Распределить элементы по блокам
        int bucket_index = (int)floor((arr[i] - min_val) / range); // // Вычислить индекс блока, к которому относится текущий элемент
        if (bucket_index == BUCKET_SIZE) {
            bucket_index--;
        }
        int j = 0; // Найти позицию для вставки элемента в блоке
        while (j < bucket_sizes[bucket_index] && arr[i] > buckets[bucket_index][j]) {
            j++;
        }
        for (int k = bucket_sizes[bucket_index] - 1; k >= j; k--) { // Сдвинуть элементы в блоке, чтобы освободить место для вставки нового элемента
            buckets[bucket_index][k + 1] = buckets[bucket_index][k];
        }
        buckets[bucket_index][j] = arr[i]; // Вставить элемент в блок и увеличить размер блока
        bucket_sizes[bucket_index]++;
    }


    int index = 0; // Собрать отсортированный массив из блоков
    for (int i = 0; i < BUCKET_SIZE; i++) {
        for (int j = 0; j < bucket_sizes[i]; j++) {
            arr[index++] = buckets[i][j];
        }
    }
}

//Сортировка слиянием 
void Merge(int arr[], int first, int last)
{
    int middle, start, final, j;
    int* mas = new int[100];
    middle = (first + last) / 2; // Находим середину массива
    start = first; // Устанавливаем начало первой половинки
    final = middle + 1; // Устанавливаем начало второй половинки
    for (j = first; j <= last; j++) // Слияние половинок
        if ((start <= middle) && ((final > last) || (arr[start] < arr[final]))) /* Если элемент из первой половинки меньше, чем из второй 
            добавляем его в временный массив*/
        {
            mas[j] = arr[start];
            start++;
        }
        else
        {
            mas[j] = arr[final];// Иначе добавляем элемент из второй половинки
            final++;
        }
    for (j = first; j <= last; j++) arr[j] = mas[j]; // Копируем отсортированный массив из временного массива в исходный
    delete[]mas;
}

void MergeSort(int arr[], int first, int last)
{
    {
        if (first < last)
        {
            MergeSort(arr, first, (first + last) / 2); 
            MergeSort(arr, (first + last) / 2 + 1, last); 
            Merge(arr, first, last); 
        }
    }
}

//Быстрая сортировка
void quicksort(int arr[], int first, int last)
{
    int mid, count;
    int f = first, l = last;
    mid = arr[(f + l) / 2]; 
    do
    {
        while (arr[f] < mid) f++;
        while (arr[l] > mid) l--;
        if (f <= l) 
        {
            count = arr[f];
            arr[f] = arr[l];
            arr[l] = count;
            f++;
            l--;
        }
    } while (f < l);
    if (first < l) quicksort(arr, first, l);
    if (f < last) quicksort(arr, f, last);
}

//Сортировка подсчетом
void countSort(int arr[], int n) {
    // Находим минимальное значение в массиве
    int min = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    // "Смещаем" значения входного массива, чтобы все значения были неотрицательными
    for (int i = 0; i < n; i++) {
        arr[i] -= min;
    }

    // Сортировка подсчетом на измененном массиве
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    int* count = new int[max + 1] {0};
    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }
    for (int i = 1; i <= max; i++) {
        count[i] += count[i - 1];
    }
    int* output = new int[n];
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }

    // Восстанавливаем значения в отсортированном массиве
    for (int i = 0; i < n; i++) {
        arr[i] += min;
    }

    delete[] output;
    delete[] count;
}


int main() {
    srand(time(NULL));
    setlocale(LC_ALL, "RUS");
    int n;
    int arr[ARRAY_SIZE];
    cout << "Блочная сортировка" << endl;
    cout << "Элементы массива: ";
    for (int i = 0; i < ARRAY_SIZE; i++) {
        arr[i] = rand() % 50 - 20;
        cout << arr[i] << ' ';
    }
    cout << endl << "Отсортированный массив: ";
    bucketSort(arr, ARRAY_SIZE);
    for (int i = 0; i < ARRAY_SIZE; i++) {
        cout << arr[i] << ' ';
    }
    cout << endl << endl;
    cout << "Сортировка слиянием" << endl;
    cout << "Введите количество элементов массива: "; cin >> n;
    int* arr1 = new int[n];
    cout << "Элементы массива: ";
    for (int i = 0; i < n; i++) {
        arr1[i] = rand() % 50-20;
        cout << arr1[i] << ' ';
    }
    cout << endl << "Отсортированный массив: ";
    MergeSort(arr1, 0, n - 1);
    for (int i = 0; i < n; i++) {
        cout << arr1[i] << ' ';
    }
    cout << endl << endl;
    delete[] arr1;
    cout << "Быстрая сортировка" << endl;
    cout << "Введите количество элементов массива: "; cin >> n;
    int* arr2 = new int[n];
    cout << "Элементы массива: ";
    for (int i = 0; i < n; i++) {
        arr2[i] = rand() % 50 - 20;
        cout << arr2[i] << ' ';
    }
    cout << endl << "Отсортированный массив: ";
    quicksort(arr2, 0, n - 1);
    for (int i = 0; i < n; i++) {
        cout << arr2[i] << ' ';
    }
    cout << endl << endl;
    delete[] arr2;
    cout << "Сортировка подсчётом" << endl;
    cout << "Введите количество элементов массива: "; cin >> n;
    int* arr3 = new int[n];
    cout << "Элементы массива: ";
    for (int i = 0; i < n; i++) {
        arr3[i] = rand() % 50-20;
        cout << arr3[i] << ' ';
    }
    cout << endl << "Отсортированный массив: ";
    countSort(arr3, n);
    for (int i = 0; i < n; i++) {
        cout << arr3[i] << ' ';
    }
    cout << endl << endl;
    delete[] arr3;
    return 0;
}